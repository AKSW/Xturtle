/*******************************************************************************
 * Copyright (c) 2013 AKSW Xturtle Project, itemis AG (http://www.itemis.eu).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
/*
 * generated by Xtext
 */
package de.itemis.tooling.xturtle.scoping;

import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.util.IResourceScopeCache;

import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.inject.Inject;
import com.google.inject.Provider;

import de.itemis.tooling.xturtle.xturtle.DirectiveBlock;
import de.itemis.tooling.xturtle.xturtle.PrefixId;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class XturtleScopeProvider extends AbstractDeclarativeScopeProvider {
	@Inject
	IResourceScopeCache cache;

	IScope scope_QNameDef_prefix(DirectiveBlock m, EReference ref){
		return getNamespacePrefixScope(m,ref);
	}
	IScope scope_QNameRef_prefix(DirectiveBlock m, EReference ref){
		return getNamespacePrefixScope(m,ref);
	}

	private IScope getNamespacePrefixScope(final DirectiveBlock b, EReference ref){
		List<PrefixId> prefixIds = cache.get(b, b.eResource(), new Provider<List<PrefixId>>() {
			public List<PrefixId> get() {
				List<PrefixId> list = EcoreUtil2.getAllContentsOfType(b.getDirectives(), PrefixId.class);
				Collections.reverse(list);

				Set<String> prefixes=new HashSet<String>();
				Iterator<PrefixId> iterator= list.iterator();
				//only the last occurence of a prefix can be linked
				//not removing them would show them in content assist nonetheless
				while(iterator.hasNext()){
					PrefixId id = iterator.next();
					if(prefixes.contains(id.getId())){
						iterator.remove();
					}else{
						prefixes.add(id.getId());
					}
				}
				return list;
			}
		});
		//only the prefixes defined within the model are visible
		IScope outer=b.eContainer()==null
				?IScope.NULLSCOPE
				:getScope(b.eContainer(), ref);
		return Scopes.scopeFor(prefixIds, new Function<PrefixId, QualifiedName>() {
			public QualifiedName apply(PrefixId def){
					return QualifiedName.create("",Optional.fromNullable(def.getId()).or(""));
			}
		}, outer);
	}
}
